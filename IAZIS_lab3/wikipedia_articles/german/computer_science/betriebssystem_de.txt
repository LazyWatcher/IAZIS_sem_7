Заголовок: Betriebssystem
URL: https://de.wikipedia.org/wiki/Betriebssystem
Язык: de
Категория: computer_science
Дата загрузки: 2025-12-07 12:00:45
Длина текста: 40922 символов

Ein Betriebssystem, auch OS (von englisch operating system) genannt, ist eine Zusammenstellung von Computerprogrammen, die die Systemressourcen eines Computers wie Arbeitsspeicher, Festplatten, Ein- und Ausgabegeräte verwaltet und diese Anwendungsprogrammen zur Verfügung stellt. Das Betriebssystem bildet dadurch die Schnittstelle zwischen den Hardware-Komponenten und der Anwendungssoftware des Benutzers. Betriebssysteme bestehen in der Regel aus einem Kernel (deutsch: Kern), der die Hardware des Computers verwaltet, sowie speziellen Programmen, die beim Start unterschiedliche Aufgaben übernehmen. Zu diesen Aufgaben gehört unter anderem das Laden von Gerätetreibern. Betriebssysteme finden sich in fast allen Arten von Computern: Als Echtzeitbetriebssysteme auf Prozessrechnern und eingebetteten Systemen, auf Personal Computern, Tabletcomputern, Smartphones und auf größeren Mehrprozessorsystemen wie z. B. Servern und Großrechnern. Die Aufgaben eines Betriebssystems lassen sich wie folgt zusammenfassen: Benutzerkommunikation; Laden, Ausführen, Unterbrechen und Beenden von Programmen; Verwaltung und Zuteilung der Prozessorzeit; Verwaltung des internen Speicherplatzes für Anwendungen; Verwaltung und Betrieb der angeschlossenen Geräte; Schutzfunktionen z. B. durch Zugriffsbeschränkungen. Die Gewichtung zwischen diesen Aufgaben wandelte sich im Laufe der Zeit, insbesondere wird Schutzfunktionen wie dem Speicherschutz oder begrenzten Benutzerrechten heute eine höhere Bedeutung zugemessen als noch in den 1990er Jahren. Dies macht Systeme allgemein robuster, reduziert z. B. die Zahl der Programm- und Systemabstürze und macht das System auch stabiler gegen Angriffe von außen, etwa durch Computerviren. Dieser Artikel behandelt den Begriff „Betriebssystem“ hauptsächlich im Kontext „allgemein zur Informationsverarbeitung verwendete Computersysteme“. Daneben sind Betriebssysteme (mit ggf. spezialisierter Funktionalität) grundsätzlich in nahezu allen Geräten im Einsatz, in denen Software betrieben wird (wie Spielecomputer, Mobiltelefone, Navigationssysteme, Maschinen der Maschinenbaubranchen u. v. a.). Auch viele Steuerungssysteme (eingebettetes System) die z. B. in Flugzeugen, Autos, Zügen, oder in Satelliten zu finden sind, besitzen spezialisierte Betriebssysteme. Definitionen und Abgrenzung Ein Betriebssystem übernimmt zwei wesentliche Aufgaben, die im Grunde in keinem direkten Zusammenhang zueinander stehen: Die eine Aufgabe besteht darin, dem Anwendungsprogrammierer saubere Abstraktionen der Betriebsmittel zur Verfügung zu stellen (anstelle der unschönen Hardware). Das Betriebssystem bietet somit eine leichter verständliche und besser handhabbare Schnittstelle zur eigentlichen Maschine an und „versteckt“ die Komplexität der darunterliegenden Maschine: „Der Ansprechpartner für den Programmierer ist also nicht mehr die wirkliche Maschine, sondern eine virtuelle Maschine (Betriebssystem), welche wesentlich einfacher zu verstehen und zu programmieren ist.“ Das Betriebssystem erzeugt abstrakte Objekte, um die Komplexität beherrschbar zu machen. Ein Beispiel für eine solche Abstraktion ist die Datei. Diese kann beispielsweise in Form eines Digitalfotos, einer gespeicherten E-Mail-Nachricht oder einer Website vorliegen. Es ist auf jeden Fall einfacher, sich damit zu beschäftigen, als mit den Details von Festplattenspeichern. Die andere Aufgabe besteht darin, die Hardwareressourcen zu verwalten: „Ein Betriebssystem muss eine geordnete und kontrollierte Zuteilung von Prozessoren, Speichereinheiten und Peripheriegeräten unter den verschiedenen Programmen, welche darum konkurrieren, sicherstellen.“ Das Betriebssystem ordnet und kontrolliert die Allokation der Prozessoren, Speicher und Ein-/Ausgabegeräte und überwacht, welches Programm gerade welches Betriebsmittel nutzt. Liegen beispielsweise mehrere Aufträge für einen Drucker vor, so muss festgelegt werden, wie diese abgearbeitet werden. Auf einem modernen Betriebssystem können dadurch auch mehrere Programme gleichzeitig ausgeführt werden. Benutzen mehrere Anwender einen Computer oder ein Netzwerk, dann gewinnen Maßnahmen zur Verwaltung und zum Schutz von Speicher, Ein-/Ausgabegeräten und anderen Betriebsmitteln noch an Bedeutung. Die Benutzer würden sich sonst gegenseitig stören. Die Gesamtheit aller Programme und Dateien, die sämtliche Abläufe bei Betrieb eines Rechners steuern, wird Systemsoftware genannt. Dazu gehören Betriebssysteme, aber auch systemnahe Software wie Compiler, Interpreter und Editoren. Anwendungssoftware wie beispielsweise Browser oder Buchhaltungssoftware benutzen die Systemsoftware für einen ordnungsgemäßen Ablauf. In der Literatur wird der Begriff „Betriebssystem“ innerhalb der Systemsoftware unterschiedlich breit interpretiert. In der DIN-Sammlung 44300 (veraltet, ersetzt durch ISO/IEC 2382:2015 siehe: Liste der DIN-Normen/DIN 1–49999 unter DIN 44300) geht die Definition von seiner Aufgabe und Stellung in einer Programmhierarchie aus: Für Andrew S. Tanenbaum beschränkt sich der Begriff Betriebssystem im Wesentlichen auf den Kernel: „Editoren, Compiler, Assembler, Binder und Kommandointerpreter sind definitiv nicht Teil des Betriebssystems, auch wenn sie bedeutsam und nützlich sind.“ Viele Lehrbücher folgen dieser engeren Sichtweise. Andere Autoren zählen unter anderem auch eine Kommandosprache zum Betriebssystem: „Außer die Hardware zu verwalten […], bieten moderne Betriebssysteme zahlreiche Dienste an, etwa zur Verständigung der Prozesse untereinander, Datei- und Verzeichnissysteme, Datenübertragung über Netzwerke und eine Befehlssprache.“ Eine noch weitere Fassung des Begriffes, die beispielsweise auch Editoren und Compiler umfasst, geht zum Teil auf ältere Werke des deutschen Sprachraums zurück, lässt sich aber auch in aktueller Literatur noch finden. So zählen die Autoren des Informatik-Dudens auch Übersetzungsprogramme und Dienstprogramme zu den wesentlichen Komponenten eines Betriebssystems. In jüngerer Zeit kann der GNU/Linux-Namensstreit als Beispiel für die Abgrenzungsprobleme angesehen werden. Der Begriff des Betriebssystems ist in Artikel 3 der Richtlinie (EU) 2019/882 (Richtlinie über die „Barrierefreiheitsanforderungen für Produkte und Dienstleistungen“) legal definiert. Diese Definition zählt die Standardschnittstelle einschließlich einer grafischen Nutzerschnittstelle zum Betriebssystem. Ungeachtet dessen, wie weit oder wie eng man den Begriff „Betriebssystem“ fasst, enthalten die Installationsmedien für Betriebssysteme für gewöhnlich zusätzliche Dienst- und Anwendungsprogramme. Entwicklungsstufen Die Entwicklung von Computer-Betriebssystemen verlief und verläuft parallel zur Entwicklung und Leistungsfähigkeit verfügbarer Hardware: Beide Linien bedingten sich gegenseitig und ermöglichten bzw. erforderten Weiterentwicklungen auf der ‚anderen‘ Seite. Die Entwicklung verlief zum Teil in kleinen, manchmal in größeren Sprüngen: Lochkarten verarbeitende Systeme (gilt sinngemäß auch für Lochstreifen) gehören mittlerweile (seit Anfang der 1970er Jahre) der Vergangenheit an. Jedoch sind sie ein guter Ansatz zur Betrachtung der Systementwicklung: In diesen räumlich relativ großen Systemen gab es noch keine externen elektronischen Speichermedien. Die Programme lagen (in Maschinensprache) in Form von Lochkartenstapeln vor und wurden durch den Operator über den Lochkartenleser in den internen Speicher ‚eingelesen‘. Nach der „Ende-Karte“ wurde das Anwendungsprogramm gestartet, das seine Eingabedaten je nach Aufgabenstellung ebenfalls über den Kartenleser lesen (deshalb der Begriff Stapelverarbeitung, engl. batch processing, queued systems) und seine Ergebnisse direkt über einen Drucker und/oder über den Kartenstanzer ausgeben musste. Vor- und nachgelagert waren, mithilfe elektro-mechanischer Geräte (Kartenlocher, Mischer, Sortierer) ausgeführt, Erfassungs-, Misch- und Sortiervorgänge erforderlich. Bereits zu diesem Zeitpunkt war die interne Verarbeitung deutlich schneller als die Ein-/Ausgabegeräte; das Lesen eines Lochkartenstapels (Karton mit 2000 Karten) dauerte ca. 5–10 Minuten, die Arbeitsspeichergrößen solcher Rechner lagen bei ca. 16 bis 64 kiB (Beispiel siehe System/360). Diese Maschinen besaßen kein konventionelles Betriebssystem, wie es heute geläufig ist. Lediglich ein Kontrollprogramm (resident monitor) wurde im Speicher gehalten und sorgte für den reibungslosen Ablauf, indem es die Kontrolle an die momentan auszuführenden Programme übergab. Der Rechner konnte stets nur ein Programm nach dem anderen ausführen. Eine Weiterentwicklung – Multiprogrammed Batch Systems – konnte zusätzliche Geräte unterstützen (Magnetbandeinheiten, erste Magnetplatten mit z. B. 7,25 MB Speichervolumen), mehrere Programme gleichzeitig ausführen (z. B. in 3 'Partitionen') sowie Programme und Daten auf externen Speichern halten. Eine schnellere Abarbeitung war möglich, da die Zeit für das Lesen und Ausgeben der Kartenstapel entfiel – und die Prozessoren schneller wurden. Hier wurden Mechanismen wie das Spooling (Zwischenausgabe von Druckerdaten auf Magnetband mit verzögertem, parallel möglichem Drucken) und die Möglichkeit des Offline-Betriebs bereits ausgiebig genutzt. Jedoch war ein Programm nötig, welches sich der Aufgaben E/A-Verwaltung, Speicherverwaltung und vor allem CPU-Scheduling etc. annimmt. Ab diesem Zeitpunkt konnte man von ersten Betriebssystemen reden. Die nächsten Schritte waren dann Folgen der jeweiligen Aufgabenbereiche, die den Systemen zukamen. Folgende Systeme sind entstanden und bis zum heutigen Tage im Einsatz: Parallele Systeme, Verteilte Systeme, Personal-Computer-Systeme, Time-Sharing-Systeme, Real-Time-Systeme und in neuester Zeit auch die Personal Digital Assistants und Smartphones. Im PC-Bereich sind derzeit die meistgenutzten Betriebssysteme die verschiedenen Varianten von Windows von Microsoft (führend bei Systemen mit GUI), BSD inkl. macOS von Apple (am weitesten verbreitetes Desktop-Unix) und GNU/Linux (führend bei Servern). Für spezielle Anwendungen (Beispiel: industrielle Steuerung) werden auch experimentelle Betriebssysteme für Forschungs- und Lehrzwecke eingesetzt. Neben den klassischen Varianten gibt es noch spezielle Betriebssysteme für verteilte Systeme, bei denen zwischen dem logischen System und den physischen System(en) unterschieden wird. Der logische Rechner besteht aus mehreren physischen Rechnereinheiten. Viele Großrechner, Number-Cruncher und die Systeme aus dem Hause Cray arbeiten nach diesem Prinzip. Eines der bekanntesten Betriebssysteme im Bereich verteilte Systeme ist Amoeba. Aufgaben Zu den Aufgaben eines Betriebssystems gehören meist: Speicherverwaltung Verwaltung der Systemressource Hauptspeicher. Protokollierung der Speichernutzung. Reservierung und Freigabe von Speicher. (Prozess)-Verwaltung Überwachung der Speicherzugriffe und gegebenenfalls Beenden von Prozessen bei einer Schutzverletzung. Erzeugung neuer Prozesse (entweder auf Anforderung des Betriebssystems oder auf Aufforderung anderer schon existierender Prozesse) und Reservierung des von den Prozessen benötigten Speichers. Kommunikation und Synchronisation von Prozessen untereinander (Interprozesskommunikation) Geräte- und Dateiverwaltung Effiziente Zuweisung von Ein-/Ausgabegeräten und Vermittlungseinheiten (Datenkanäle, Steuereinheiten), Vermeidung von Konflikten Initiierung, Überwachung der Ausführung, Terminierung von Ein-/Ausgabevorgängen. Verwaltung des Dateisystems. Erzeugung eines Namensraums mit zugehörigen Speicherobjekten und gegebenenfalls weiteren Objekten. Rechteverwaltung Voneinander unabhängige Benutzer/Programme dürfen sich gegenseitig nicht stören. Abstraktion Verbergen der Komplexität der Maschine vor dem Anwender Abstraktion des Maschinenbegriffes (nach Coy): Reale Maschine = Zentraleinheit + Geräte (Hardware) Abstrakte Maschine = Reale Maschine + Betriebssystem Benutzermaschine = Abstrakte Maschine + Anwendungsprogramm Als Gerät aus der Sicht eines Betriebssystems bezeichnet man aus historischen Gründen alles, was über Ein-/Ausgabekanäle angesprochen wird. Dies sind nicht nur Geräte im herkömmlichen Sinn, sondern mittlerweile auch interne Erweiterungen wie Grafikkarten, Netzwerkkarten und anderes. Die (Unter-)Programme zur Initialisierung und Ansteuerung dieser „Geräte“ bezeichnet man zusammenfassend als Gerätetreiber. Betriebsmittelverwaltung und Abstraktion Als Betriebsmittel oder Ressourcen bezeichnet man alle von der Hardware eines Computers zur Verfügung gestellten Komponenten, also den Prozessor (bei Mehrprozessorsystemen die Prozessoren), den physischen Speicher und alle Geräte wie Festplatten-, Disketten- und CD-ROM-Laufwerke, Netzwerk- und Schnittstellenadapter und andere. Die Hardware Compatibility List enthält alle Hardware-Produkte, die im Zusammenhang mit einem bestimmten Betriebssystem auf ihre Funktionalität hin getestet wurden. Einführendes Beispiel: Zeitgeberbausteine Moderne Rechnersysteme besitzen Zeitgeberbausteine (Timer). In frühen PCs wurde z. B. der Baustein 8284 des Unternehmens Intel eingesetzt. Dieser Baustein muss zunächst initialisiert werden. Er kann dann nach Ablauf einer Zeitspanne oder periodisch den Prozessor unterbrechen und ihn zur Abarbeitung einer eigenen Routine veranlassen. Neben der Initialisierung ist eine Unterbrechungsroutine zu erstellen, deren Aufruf in einer dafür geeigneten Sprache (meist Assembler) programmiert werden muss. Da Unterbrechungen asynchron auftreten, sind komplexe Verhältnisse hinsichtlich der Datenstrukturen zu berücksichtigen. Genaue Kenntnisse des Bausteins (Datenblatt), der Computerhardware (Unterbrechungsbehandlung) und des Prozessors sind erforderlich. Die einzelnen Komponenten, die an diesem Prozess beteiligt sind, fasst man unter dem Begriff Rechnerarchitektur zusammen. Virtuelle Prozessoren Ein modernes Mehrprogrammbetriebssystem verwendet einen solchen Zeitgeberbaustein, um den normalerweise einzigen Prozessor periodisch (normalerweise im Millisekundenbereich) zu unterbrechen und eventuell mit einem anderen Programm fortzufahren (sogenanntes präemptives Multitasking). Die Initialisierung und die Unterbrechungsroutine werden dabei vom Betriebssystem implementiert. Auch wenn nur ein einzelner Prozessor zur Verfügung steht, können mehrere Programme ausgeführt werden, jedes Programm erhält einen Teil der Prozessorzeit (Scheduling). Jedes Programm verhält sich, bis auf die verlangsamte Ausführungszeit, so, als hätte es einen eigenen virtuellen Prozessor. Virtuelle Zeitgeber Über einen Systemruf, zum Beispiel alarm, wird jedem Programm darüber hinaus ein eigener virtueller Zeitgeber zur Verfügung gestellt. Das Betriebssystem zählt die Unterbrechungen des Original-Zeitgebers und informiert Programme, die den alarm-Systemruf verwendeten. Die einzelnen Zeitpunkte werden über eine Warteschlange verwaltet. Abstraktion Die Hardware des Zeitgebers ist damit vor den Programmen verborgen. Ein System mit Speicherschutz erlaubt den Zugriff auf den Zeitgeberbaustein nur über den Kernel und nur über exakt definierte Schnittstellen (meist Systemrufe genannt, die über spezielle Prozessorbefehle wie TRAP, BRK, INT realisiert werden). Kein Programm kann somit das System gefährden, die Verwendung des virtuellen Zeitgebers ist einfach und portabel. Der Anwender oder Programmierer braucht sich nicht um die (komplexen) Details zu kümmern. Virtualisierung weiterer Betriebsmittel So wie Prozessoren und Zeitgeber virtualisiert werden, ist dies auch für alle anderen Betriebsmittel möglich. Dabei werden einige Abstraktionen teilweise nur als Software implementiert, andere erfordern spezielle Hardware. Dateisysteme Über Dateisysteme werden die Details der externen Speichersysteme (Festplatten-, Disketten- oder CD-ROM-Laufwerke) verborgen. Dateinamen und Verzeichnisse erlauben den bequemen Zugriff, die eigentlich vorhandene Blockstruktur und die Geräteunterschiede sind vollkommen unsichtbar. Interner Speicher Der interne Speicher (RAM) wird auch Arbeitsspeicher genannt und vom Betriebssystem in Blöcke (Kacheln) aufgeteilt, die den geladenen Programmen auf Anforderung zur Verfügung gestellt werden. Meist wird der Speicher initialisiert, das bedeutet, dass dabei allenfalls noch vorhandene Daten zuvor gelöscht werden. Über virtuellen Speicher wird bei vielen Systemen jedem Programm ein kontinuierlicher (zusammenhängender) Bereich zur Verfügung gestellt. Die Virtuelle Speicherverwaltung erlaubt einen flexiblen Ansatz, bei dem der reale physisch vorhandene Speicher weder zusammenhängend sein muss (Segmentierung), noch muss er in Summe real wirklich so groß sein, wie es aus Sicht der Programme scheint. Stattdessen werden einzelne Speicherblöcke, englisch pages, nach Bedarf zwischen Arbeitsspeicher (RAM) und externem Speicher (z. B. die Auslagerungsdatei) hin und her geschoben (Paging). Netzwerk Die Details der Netzwerkzugriffe werden verborgen, indem auf die eigentliche Hardware (Netzwerkkarte) ein Protokollstapel aufgesetzt wird. Die Netzwerksoftware erlaubt beliebig viele virtuelle Kanäle. Auf der Ebene der Sockets (Programmierung) ist die Netzwerkkarte vollkommen unsichtbar, das Netzwerk hat viele neue Fähigkeiten (bidirektionale, zuverlässige Datenströme, Adressierung, Routing) bekommen. Bildschirm Als Grafische Benutzeroberfläche (GUI, Abk. für engl. Graphical User Interface) wird generell eine Bildschirmausgabe beschrieben, wenn sie über eine Eingabeaufforderung hinausgeht. Mit den richtigen Grafikkarten und Bildschirmen ist die Darstellung von geometrischen Objekten (Linien, Kreisen, Ellipsen, aber auch Schriftattributen und Farben) auf dem Bildschirm möglich, aus denen sich komplexere geometrische Elemente wie Knöpfe, Menüs, Benutzeroberflächen etc. zum einfachen Steuern von Programmen erstellen lassen. Die Grafikkarte als Hardware ist für den Programmierer und Anwender vollkommen verborgen. Klassifikation Betriebssystemarten Betriebssysteme können je nach ihren Merkmalen und Funktionen in verschiedene Kategorien unterteilt werden. Betriebsarten Batch System (Jobsystem, Stapelverarbeitung) Der Nutzer muss warten, bis sein Programm an der Reihe ist. Die Antwortzeit des Systems ist nicht begrenzt. Beispiele: DOS, OS/2, Windows. Dialogsystem (interaktives System) Eine einzelne Antwort kann lange dauern, aber im Durchschnitt erfolgt die Antwort innerhalb einer vorgegebenen Zeit. Die mittlere Antwortzeit des Betriebssystems liegt unterhalb eines bestimmten Grenzwertes. Beispiele: MS Windows XP, Windows 7/8, Unix, Linux. Echtzeitsystem Das Betriebssystem antwortet sofort. Die Einhaltung eines gegebenen Grenzwertes für die Antwortzeit ist in jedem Fall erforderlich. Beispiele: QNX, VxWorks. Anzahl der parallel bedienbaren Nutzer (Quelle: ) Ein-Nutzer-Betriebssystem (single user) Nur ein Nutzer kann das System gleichzeitig verwenden. Beispiele: Betriebssysteme auf Handys, Navigationssysteme in Fahrzeugen. Mehr-Nutzer-Betriebssystem (multi user) Das System kann gleichzeitig mehrere verschiedene Nutzer verwalten und (quasi-)parallel bedienen. Beispiele: Unix, Linux. Anzahl der parallel bearbeitbaren Nutzeraufträge (Quelle: ) Ein-Prozess-Betriebssystem (single tasking) Nur ein Auftrag (Prozess) kann zu einem Zeitpunkt durch das System bearbeitet werden. Beispiel: MS-DOS. Mehr-Prozess-Betriebssystem (multi tasking) Das System kann gleichzeitig mehrere verschiedene Aufträge verwalten und (quasi-)parallel bearbeiten. Eine Weiterentwicklung dieses Prinzips ist das Multithreading, bei dem mehrere Threads in einem Prozess zusammengefasst werden können. Beispiele: Unix, Linux, Windows XP, Windows 7, Windows 8. Diese verschiedenen Arten von Betriebssystemen bieten unterschiedliche Funktionen und Fähigkeiten, um den vielfältigen Anforderungen und Nutzungsszenarien gerecht zu werden. Die Wahl des richtigen Betriebssystems hängt von den spezifischen Bedürfnissen und Zielen eines Benutzers oder einer Organisation ab. Geschichte Erste Betriebssysteme (bis 1980) Die ersten Computer kamen ohne echtes Betriebssystem aus, da lediglich ein einziges Programm im Stapelbetrieb geladen sein konnte und die unterstützte Hardware noch sehr überschaubar war. Der erste Digitalrechner wurde von Charles Babbage (1792–1872) entwickelt. Er sah bereits die Notwendigkeit, seine „Analytische Maschine“ mit Software zu betreiben. Er stellte die Tochter des bekannten Dichters Lord Byron Ada Lovelace ein, um erste Programme zu schreiben. Ada Lovelace gilt als die erste Programmiererin. Charles Babbage gelang es nie, seine „Analytische Maschine“ vernünftig zum Laufen zu bringen. Zahnräder, Gestänge und andere mechanische Teile konnten nicht in der notwendigen Präzision hergestellt werden. Nach den erfolglosen Versuchen von Charles Babbage wurden wenige Anstrengungen unternommen, ein weiteres Projekt Digitalrechner auf die Beine zu stellen. Erst vor dem Zweiten Weltkrieg wurden Babbages Ideen wieder aufgegriffen. Erste digitale Rechner wurden auf Basis von elektrischen Relais und Röhren realisiert. Zu den ersten Wissenschaftlern gehörten Howard Aiken von der Harvard-Universität, John von Neumann an der Princeton-Universität, John William Mauchly, John Presper Eckert in Pennsylvania und Konrad Zuse in Berlin. Die ersten Computer wurden von einem Team von Technikern entwickelt, welche für den Entwurf, den Bau, die Programmierung und Wartung solcher Maschinen verantwortlich waren. Programmiersprachen waren unbekannt und die Programme wurden mithilfe von Steckkarten realisiert, auf welchen die Programme mithilfe von elektrischen Drähten programmiert wurden. Da ein Computer nur ein einziges Programm ausführen konnte, waren Betriebssysteme unnötig. Eine Berechnung einer einzigen Aufgabe dauerte Sekunden, und die Ausführung eines Programmes Stunden, aber nur dann, wenn die Computer mit Tausenden von Röhren oder Relais einwandfrei funktionierten. In den frühen 1950er Jahren wurden elektrische Drähte durch Lochkarten ersetzt. Als Betriebssystem-Vorläufer gilt der 1956 in Gestalt des GM-NAA I/O bei General Motors für die IBM 704 erfundene resident monitor, ein Stück Software, das nach Beendigung eines Stapelauftrags den Folgeauftrag automatisch startete. 1959 entstand daraus das SHARE Operating System (SOS), das bereits über eine rudimentäre Ressourcenverwaltung verfügte. Dessen Nachfolger IBSYS verfügte bereits über eine einfache Shell mit Kommandosprache. 1961 entstand mit dem Compatible Timesharing System (CTSS) für die IBM 7094 am MIT das erste Betriebssystem für Mehrbenutzerbetrieb. Das ermöglichte die quasi-gleichzeitige Benutzung der Rechenanlage durch mehrere Anwender mittels angeschlossener Terminals. Eine Vielzahl gleichzeitig geladener Programme erforderte es, die von ihnen beanspruchten Speicherbereiche voneinander abzugrenzen. Als Lösung entstand 1956 an der TU Berlin der Virtuelle Speicher und wurde Mitte der 1960er Jahre erstmals in Großrechner-Betriebssystemen umgesetzt. Damals lieferte meist der Hersteller der Hardware das Betriebssystem, das nur auf einer bestimmten Modellreihe oder sogar nur auf einem bestimmten System lief, sodass Programme weder zwischen verschiedenen Computern, noch über verschiedene Generationen hinweg portierbar waren. Mit der Einführung der Modellreihe System/360 von IBM führte IBM 1964 das Betriebssystem OS/360 in verschiedenen Versionen (OS/360 für rein lochkartenbasierte Systeme, TOS/360 für Maschinen mit Bandlaufwerken, DOS/360 für solche mit Festplatten) ein. Es war das erste Betriebssystem, das modellreihenübergreifend eingesetzt wurde. Ab 1963 wurde Multics in Zusammenarbeit von MIT, General Electric und den Bell Laboratories (Bell Labs) von AT&T entwickelt, das jedoch erst ab 1969 bis 2000 im Einsatz war. Multics wurde in PL/I programmiert. Inspiriert von den Arbeiten an Multics startete eine Gruppe um Ken Thompson und Dennis Ritchie an den Bell Labs 1969 mit der Entwicklung von Unix. In den Jahren 1970 bis 1972 wurden mit RSX-15 und RSX-11 frühe Vorläufer des heutigen Windows NT entwickelt. Unix wurde in den Jahren 1972–1974 bis auf wenige Teile in der höheren Programmiersprache C mit dem Ziel der Portabilität neu implementiert, um auf der damals neuen PDP-11 lauffähig zu sein. In weiterer Folge entwickelte sich UNIX zu einer ganzen Familie von Systemen für verschiedene Hardwareplattformen. Die ersten PCs wie der Altair 8800 von 1975 verfügten zunächst über kein Betriebssystem. Daher mussten sämtliche Aktionen in einem reinen Maschinencode eingegeben werden. Sein erstes Betriebssystem erhielt der Altair 8800 in Form eines BASIC-Interpreters. Dieser stellte sowohl eine Programmierumgebung dar als auch die allgemeine Schnittstelle zwischen dem Benutzer und der Hardware (die dieser Interpreter direkt ansteuerte). Er war Laufzeitumgebung und Benutzerschnittstelle zugleich; über bestimmte Befehle konnte der Benutzer beispielsweise Daten laden und speichern und Programme ausführen. 1974 erfand Gary Kildall CP/M, das als erstes universelles PC-Betriebssystem gilt. Durch seine modulare Bauweise (der plattformunabhängige Kernel BDOS setzte auf einer Hardware-Treiberschicht namens BIOS auf) ließ es sich mit vertretbarem Aufwand auf zahlreiche zueinander inkompatible PC-Plattformen portieren. Eine Programmierumgebung steuerte nun (meistens) nicht mehr die Hardware direkt an, sondern nutzte die Schnittstellen des Betriebssystems. Daher war auch die Programmierumgebung nicht mehr nur auf einer bestimmten Hardware lauffähig, sondern auf zahlreichen PCs. Für die aufkommende Computergrafik reichten rein textbasierte Benutzerschnittstellen nicht mehr aus. Die 1973 eingeführte Xerox Alto war das erste Computersystem mit einem objektorientierten Betriebssystem und einer grafischen Benutzeroberfläche, was diesen Rechner für Desktop-Publishing geeignet machte und einen großen Fortschritt in Sachen Benutzerfreundlichkeit darstellte. Meilensteine Der C64, ein Heimcomputer der 1980er Jahre In den 1980er Jahren wurden Heimcomputer populär. Diese konnten neben nützlichen Aufgaben auch Spiele ausführen. Die Hardware bestand aus einem 8-Bit-Prozessor mit bis zu 64 KiB RAM, einer Tastatur und einem Monitor- bzw. HF-Ausgang. Einer der populärsten dieser Computer war der Commodore 64 (kurz „C64“) mit dem Mikroprozessor 6510 (einer Variante des 6502). Dieser Computer verfügte über einen in einem eigenen 8 KiB-ROM-Baustein befindlichen Systemkern namens Kernal mitsamt einem BIOS (Basic Input/Output System), das die Geräte Bildschirm, Tastatur, serielle IEC-Schnittstelle für Diskettenlaufwerke bzw. Drucker, Kassetteninterface initialisierte und über ein Kanalkonzept teilweise abstrahierte. Über ein separates 8 KiB-ROM-BASIC, das auf die Funktionen des BIOS aufsetzte, konnte das System bedient und programmiert werden. Das Betriebssystem dieses Computers kann auf der Ebene des BASIC-Interpreters als gute Hardwareabstraktion angesehen werden. Natürlich sind weder Kernel, Speicher- oder sonstiger Hardwareschutz vorhanden. Viele Programme, vor allem auch Spiele, setzten sich über das BIOS hinweg und griffen direkt auf entsprechende Hardware zu. Die grafische Benutzeroberfläche (GUI) von Apple Xerox entwickelte im Palo Alto Research Center (PARC) das Smalltalk-Entwicklungssystem (Xerox entwickelte mit ALTO (1973) und Star (1981) erste Rechner mit grafischer Benutzeroberfläche). Das Unternehmen Apple bot Xerox an, die Technologie zu kaufen; da PARC aber vor allem ein Forschungszentrum war, bestand kein Interesse an Verkauf und Vermarktung. Nachdem Apple-Chef Steve Jobs Xerox Aktienanteile von Apple anbot, wurde ihm erlaubt, einigen Apple-Entwicklern die Xerox-Demos zu zeigen. Danach war den Apple-Entwicklern auf jeden Fall klar, dass der grafischen Benutzeroberfläche die Zukunft gehörte, und Apple begann, eine eigene grafische Benutzeroberfläche zu entwickeln. Viele Merkmale und Prinzipien jeder modernen grafischen Benutzeroberfläche für Computer, wie wir sie heute kennen, entstammen der Arbeit des Palo Alto Research Center und des Xerox PARC (etwa die Schreibtischmetapher) und den Verbesserungen von Apple (Pull-down-Menüs, Drag and Drop, der Doppelklick). Die Behauptung, Apple habe seine GUI von Xerox kopiert, ist ein ständiger Streitpunkt; Apple hatte, anders als z. B. Digital Research, durch den Austausch von Aktien offiziell dafür bezahlt, die technologischen Innovationen bei Xerox studieren zu dürfen, und konnte auf dieser Basis sein eigenes grafisches Betriebssystem entwickeln. Zwischen einem Alto von Xerox und der Lisa (siehe Lisa OS) bzw. nach dessen Misserfolg dem Lisa-Nachfolger Macintosh (siehe Mac OS) gibt es zahlreiche Unterschiede in Aufbau und Bedienung. Der Mac-OS-Nachfolger Mitte der 1990er Jahre steckte das Unternehmen Apple in einer tiefen Krise; es schien kurz vor dem Ruin. Ein dringliches Problem war dabei, dass Apples Betriebssystem Mac OS als veraltet galt, weshalb sich Apple nach Alternativen umzusehen begann. Nach dem Scheitern des wichtigsten Projektes für ein modernes Betriebssystem mit dem Codenamen Copland sah sich Apple gezwungen, Ausschau nach einem für die eigenen Zwecke verwendbaren Nachfolger zu halten. Zuerst wurde vermutet, dass Apple das Unternehmen Be, mit ihrem auch auf Macs lauffähigen Betriebssystem BeOS, übernehmen würde. Die Übernahmeverhandlungen scheiterten jedoch im November 1996, da der frühere Apple-Manager und Chef von Be Jean-Louis Gassée im Falle einer Übernahme 300 Millionen US-Dollar und einen Sitz im Vorstand verlangte. Da Gil Amelio versprochen hatte, bis zur Macworld Expo im Januar 1997 die zukünftige Strategie zu Mac OS zu verkünden, musste schnell eine Alternative gefunden werden. Überraschend übernahm Apple dann noch im Dezember 1996 für 400 Mio. US-Dollar das Unternehmen NeXT des geschassten Apple-Gründers Steve Jobs mitsamt dem Betriebssystem NeXTStep bzw. OPENSTEP, das Apples Grundlage für die nachfolgende neue Betriebssystem-Generation werden sollte. Unter dem Codenamen Rhapsody wurde es weiterentwickelt zu einem UNIX für Heim- und Bürocomputer mit dem Namen „Mac OS X“; von Version 10.8 (2012) bis 10.11 hieß es einfach „OS X“, seit Version 10.12 (2016) „macOS“. Ab Version 10.5 ist es konform mit der Single UNIX Specification. Das Betriebssystem OPENSTEP war die erste Implementierung der OpenStep-Spezifikationen, die zusammen mit Sun entwickelt wurden. Deren Entwicklung hatte Einfluss auf Java und somit letztlich auf Android. Disk Operating System (DOS) Seinen Ursprung hat das „Disketten-Betriebssystem“ auf Großrechnern (englisch Mainframes) wie dem System/360 von IBM aus den 1960er Jahren. Der Ansatz wurde in den 1970ern mit CP/M von Digital Research auf den damals aufkommenden Personal Computern übernommen, das sich seinerseits u. a. an TOPS-10, einer Weiterentwicklung von DOS auf Großrechnern, orientierte. Ähnliche Systeme gab es daraufhin auch für den Commodore PET (Commodore DOS), den Apple II (Apple DOS) und den Atari (Atari DOS). Die Portierung von CP/M auf den Motorola 68000, genannt CP/M-68k, selbst kein großer kommerzieller Erfolg, wurde zur Grundlage für TOS, dem Betriebssystem des Atari ST. 86-DOS erschien 1980 als Nachbildung von CP/M für den Intel 8086, wurde von Microsoft gekauft und für den IBM PCs als PC DOS eingesetzt. Es setzt auf das PC-BIOS des IBM PC auf und stellt Dateisystemoperationen zur Verfügung. Microsoft vertrieb ein fast identisches System auch als MS-DOS für IBM-kompatible PCs und x86-PCs. Die ersten IBM PCs waren ganz ähnlich wie der C64 aufgebaut. Auch sie verfügten über ein eingebautes BIOS zur Initialisierung und Abstraktion der Hardware. Sogar ein BASIC-Interpreter im ROM war vorhanden. Da der IBM PC im Grundsatz ein offenes Design verwendet, wurde anfangs von der Konkurrenz versucht, ohne BIOS und BASIC dazu kompatible DOS-PCs zu bauen. Es wurde jedoch schnell klar, dass das BIOS ein unverzichtbarer Teil des IBM PC war, ohne den auch keine vollständige Kompatibilität möglich war. Nachdem das BIOS durch Reverse Engineering nachprogrammiert worden war, wurde auch in IBM-PC-kompatiblen Computern ein BIOS eingesetzt, allerdings wurde auf das ROM-BASIC verzichtet. Die auf anderen PCs und Heimcomputern eingesetzte Varianten von DOS sind nicht zu MS-DOS kompatibel, etwa AmigaDOS. PC-kompatibles DOS Der PC konnte mit seinem Intel-8088-Prozessor (16-Bit-Register) bis zu 1 MiB Speicher adressieren, die ersten Modelle waren jedoch nur mit 64 KiB ausgestattet. Diskettenlaufwerke lösten die alten Kassettenrekorder als Speichermedium ab. Sie erlauben vielfaches Schreiben und Lesen einzeln adressierbarer 512-Byte-Blöcke. Die Benutzung wird durch ein Disk Operating System (DOS) vereinfacht, das ein abstraktes Dateikonzept bereitstellt. Blöcke können zu beliebig großen Clustern (Zuordnungseinheit – kleinste für das Betriebssystem ansprechbare Einheit) zusammengefasst werden. Dateien (logische Informationseinheiten) belegen einen oder mehrere dieser (verketteten) Cluster. Eine Diskette kann viele Dateien enthalten, die über Namen erreichbar sind. Auf den ersten PCs war kein Speicherschutz realisiert, die Programme konnten daher an DOS vorbei direkt auf das PC-BIOS und, am BIOS vorbei, auch direkt auf die Hardware zugreifen, z. B. auf die Grafikkarte. Erst spätere PCs wurden mit dem Intel-80286-Prozessor ausgestattet, der Speicherschutz ermöglichte. MS-DOS stellte auch keine für alle Zwecke ausreichende Abstraktion zur Verfügung. Es ließ sich nur ein Programm gleichzeitig starten, die Speicherverwaltung war eher rudimentär. Ein Teil der Hardware wurde nicht unterstützt und musste von Programmen direkt angesprochen werden, was dazu führte, dass beispielsweise für jedes Spiel die Soundkarte neu konfiguriert werden musste. Die Performance einiger Routinen, speziell zur Textausgabe, war verbesserungswürdig. Viele Programme setzten sich daher über das Betriebssystem hinweg und schrieben z. B. direkt in den Bildschirmspeicher. MS-DOS wurde mit einem Satz von Programmen (sogenannten Werkzeugen) und dem Kommandointerpreter COMMAND.COM ausgeliefert. Windows 1983 begann das Unternehmen Microsoft mit der Entwicklung einer grafischen Betriebssystem-Erweiterung („Grafik-Aufsatz“) für MS-DOS namens Windows. Das MS-DOS und BIOS-Design der PCs erlaubten, da immer nur ein Programm exklusiv laufen konnte, keine Weiterentwicklung in Richtung moderner Serverbetriebssysteme. Microsoft begann Anfang der 1990er Jahre, ein solches Betriebssystem zu entwickeln, das zunächst als Weiterentwicklung von OS/2 geplant war (an dessen Entwicklung Microsoft zwischen 1987 und 1991 beteiligt war): Windows NT 3.1 (Juli 1993). Für den Consumer-Markt brachte Microsoft am 15. August 1995 Windows 95 heraus; es setzt auf MS-DOS auf. Dieser „Consumer-Zweig“, zusammengefasst Windows 9x, wurde mit der Veröffentlichung von Windows Me (August/September 2000) abgeschlossen. Aufbau von Windows NT: Über die Hardware wurde eine Abstraktionsschicht, der Hardware Abstraction Layer (HAL) gelegt, auf den der Kernel aufsetzte. Verschiedene Gerätetreiber waren als Kernelmodule ausgeführt und liefen wie der Kernel im privilegierten Kernel Mode. Sie stellten Möglichkeiten der E/A-Verwaltung, Dateisystem, Netzwerk, Sicherheitsmechanismen, virtuellen Speicher usw. zur Verfügung. Systemdienste (System Services) ergänzten das Konzept; wie ihre Unix-Pendants, die daemons, waren sie in Form von Prozessen im User-Mode ausgeführt. Über sogenannte Personalities wurden dann die Schnittstellen bestehender Systeme nachgebildet, zunächst für Microsofts eigenes, neues Win32-System, aber auch für OS/2 (ohne Grafik) und POSIX.1, also einer Norm, die eigentlich Unix-Systeme vereinheitlichen sollte. Personalities liefen wie Anwenderprogramme im unprivilegierten User-Mode. Das DOS-Subsystem war in Form von Prozessen implementiert, die jeweils einen kompletten PC mit MS-DOS als virtuelle Maschine darstellten; darauf konnte mit einer besonderen Version von Windows 3.1, dem Windows-on-Windows, auch Win16-Programme ausgeführt werden. Windows-on-Windows blendete dazu die Fenster der Win16-Programme in das Win32-Subsystem ein, das die Grafikausgabe verwaltete. Das System erlaubte daher die Ausführung von Programmen sowohl für MS-DOS wie für die älteren Windows-Betriebssysteme, allerdings unter vollkommener Kontrolle des Betriebssystems. Dies galt aber nur für die Implementierung für Intel-80386-Prozessoren und deren Nachfolger. Programme, die direkt auf die Hardware zugreifen, blieben aber außen vor. Insbesondere viele Spiele konnten daher nicht unter Windows NT ausgeführt werden, zumindest bis zur Vorstellung von WinG, das später in DirectX umbenannt wurde. Ohne die Möglichkeit eines direkten Zugriffs auf die Grafikhardware bzw. -treiber war die Programmierung von leistungsfähigen Actionspielen zunächst auf die älteren Windows-Versionen beschränkt. Windows NT erschien in den Versionen 3.1, 3.5, 3.51 und 4.0. Windows 2000 stellte eine Weiterentwicklung von Windows NT dar. Auch Windows XP, Windows Server 2003, Windows Vista, Windows Server 2008, Windows 7, Windows Server 2012, Windows 8/8.1 und Windows 10 bauen auf der Struktur von Windows NT auf. Linux (GNU/Linux) 1991 begann Linus Torvalds in Helsinki/Finnland mit der Entwicklung des Linux-Kernels, den er bald danach der Öffentlichkeit zur Verfügung stellte. Es läuft als portables Betriebssystem auf verschiedenen Rechnerarchitekturen, wurde aber zunächst für PCs mit Intel-80386-Prozessor entwickelt. Das in diesen Rechnern verwendete BIOS dient nur noch zum Initialisieren der Hardware und zum Starten des Bootloaders, da die Routinen des PC-BIOS für Multitaskingsysteme wie Linux ungeeignet sind. Dies kommt zustande, da insbesondere der Prozessor durch Warten belastet wird anstatt durch eine – in der Hardware durchaus vorhandene – geschickte Unterbrechungsverwaltung (interrupt handling) auf Ereignisse (events) zu reagieren. Linux verwendet daher nach dem Starten des Systems eigene Gerätetreiber. Es verteilt die Prozessorzeit auf verschiedene Programme (Prozesse). Jeder dieser Prozesse erhält einen eigenen, geschützten Speicherbereich und kann nur über Systemaufrufe auf die Gerätetreiber und das Betriebssystem zugreifen. Die Prozesse laufen im Benutzermodus (user mode), während der Kernel im Kernel-Modus (kernel mode) arbeitet. Die Privilegien im Benutzermodus sind sehr eingeschränkt. Ein direkter Zugriff wird nur sehr selten und unter genau kontrollierten Bedingungen gestattet. Dies hat den Vorteil, dass kein Programm z. B. durch einen Fehler das System zum Absturz bringen kann. Linux stellt wie sein Vorbild Unix eine vollständige Abstraktion und Virtualisierung für nahezu alle Betriebsmittel bereit (z. B. virtueller Speicher, Illusion eines eigenen Prozessors). Verbreitung Das Unternehmen StatCounter analysiert die Verbreitung von Endanwender-Betriebssystemen anhand von Zugriffsstatistiken diverser Websites. Viele Jahre lang lag Windows an der Spitze, bis es laut StatCounter 2017 von Android überholt wurde. Die laut StatCounter am weitesten verbreiteten Endanwender-Betriebssysteme sind: Siehe auch Echtzeitbetriebssystem Liste von Betriebssystemen Literatur Albrecht Achilles: Betriebssysteme. Eine kompakte Einführung mit Linux. Springer: Berlin, Heidelberg, 2006. ISBN 978-3-540-23805-8. Uwe Baumgarten, Hans-Jürgen Siegert: Betriebssysteme. Eine Einführung. 6., überarbeitete, aktualisierte und erweiterte Auflage, Oldenbourg Verlag: München, Wien, 2007. Erich Ehses, Lutz Köhler, Petra Riemer, Horst Stenzel, Frank Victor: Systemprogrammierung in UNIX / Linux. Grundlegende Betriebssystemkonzepte und praxisorientierte Anwendungen. Vieweg+Teubner: Wiesbaden, 2012. ISBN 978-3-8348-1418-0. Eduard Glatz: Betriebssysteme. Grundlagen, Konzepte, Systemprogrammierung. 1. Auflage. dpunkt: Heidelberg, 2006. ISBN 3-89864-355-7. Sibsankar Haldar, Alex A. Aravind: Operating Systems. Delhi (u. a.): Pearson Education, 2009. ISBN 978-81-317-1548-2. Helmut Herold, Bruno Lurz, Jürgen Wohlrab, Matthias Hopf: Grundlagen der Informatik. Kapitel 9: Betriebssysteme. 3., aktualisierte Auflage, Pearson: Hellbergmoos, 2017, S. 433–462. ISBN 978-3-86894-316-0. Peter Mandl: Grundkurs Betriebssysteme. Architekturen, Betriebsmittelverwaltung, Synchronisation, Prozesskommunikation, Virtualisierung. 4. Auflage, Springer Vieweg: Wiesbaden, 2014. ISBN 978-3-658-06217-0. Abraham Silberschatz, Peter Baer Galvin, Greg Gagne: Operating System Concepts. Ninth Edition, John Wiley & Sons: Hoboken, 2013. ISBN 978-1-118-06333-0. Andrew S. Tanenbaum, Herbert Bos: Moderne Betriebssysteme. 4., aktualisierte Auflage. Pearson: Hallbergmoos, 2016. ISBN 978-3-86894-270-5. Ältere zitierte Ausgabe: Andrew S. Tanenbaum: Moderne Betriebssysteme. 3., aktualisierte Auflage, Pearson Studium, 2009. Englische Originalausgabe: Modern Operating Systems. 4th Edition, Pearson, 2016. Weblinks Linkkatalog zum Thema Betriebssysteme bei curlie.org (ehemals DMOZ) Informationen zu allen Betriebssystemen Lowlevel – Wiki und Forum zur Betriebssystementwicklung (Online) == Einzelnachweise ==